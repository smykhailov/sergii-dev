{"componentChunkName":"component---src-components-article-tsx-content-file-path-home-runner-work-sergii-dev-sergii-dev-articles-2024-01-28-the-businessman-bank-logic-mdx","path":"/articles/the-businessman-bank-logic/","result":{"data":{"site":{"siteMetadata":{"title":"Sergii Mykhailov","author":"Sergii Mykhailov"}},"mdx":{"excerpt":"The bank logic in the game is one of the most complex components, as it is responsible for handling lending and borrowing money, reactingâ€¦","body":"\nThe bank logic in the game is one of the most complex components, as it is responsible for handling lending and borrowing money, reacting to the player's actions, defining new keyboard handlers, validating inputs,\nand placing the data back to the game store. It is a crucial part of the game's mechanics and requires careful design and implementation to ensure that it functions correctly.\n\nThe bank logic is responsible for managing the game's economy, which is a critical aspect of the game's overall experience. It must be designed to be robust and flexible, capable of handling a wide range of scenarios and player actions.\nThis includes managing loans, interest rates, and other financial transactions.\n\nTo achieve this, the bank logic must be carefully designed and implemented, with a focus on modularity, scalability, and maintainability. This requires a deep understanding of the game's mechanics and the underlying programming language,\nas well as a strong grasp of software engineering principles and best practices. In this article we cover only one part of it and extend, when the other parts of game logic will be implemented, as some of the actions will require other bits to be done first.\n\nThere were a lot of code changes made to the bank logic, which is not surprising given its complexity. While it is not possible to cover all of the changes in this article, I will highlight the most important ones.\nIf you are interested in seeing all of the changes, you can use GitHub's [compare feature](https://github.com/smykhailov/the-businessman/compare/v0.11...v0.12) to view the differences between branches and tags.\n\n## Store and Display data\n\nThe first thing we need to do is to display the data. We will use the `bankData` object to store the data. Also, we fill the data with the default values.\n\n```js {numberLines: 110}\nconst bankData = {\n  credit: [],\n  deposit: [],\n};\n\nfor (let i = 0; i < 12; i++) {\n  bankData.credit.push({\n    amount: 0,\n    monthsToPayBack: 0,\n    returnDay: 0,\n  });\n  bankData.deposit.push({\n    amount: 0,\n    monthsToPayBack: 0,\n    returnDay: 0,\n  });\n}\n```\n\nAt the first view it looks, that we duplicate the code, but it is done for purpose. If we create an object and then push it to the array, we will have the same object in the array. It means, that if we change the object, we will change all the objects in the array.\nThe following code looks better, but contains runtime error, as the changes to `credit` field will be also reflected in `deposit` field and vice versa, as they are the same object.\n\n```js {numberLines: 110}\nconst bankData = {\n  credit: [],\n  deposit: [],\n};\n\nfor (let i = 0; i < 12; i++) {\n  const data = {\n    amount: 0,\n    monthsToPayBack: 0,\n    returnDay: 0,\n  };\n\n  bankData.credit.push(data);\n  bankData.deposit.push(data);\n}\n```\n\nTo display the data we need to iterate over the arrays stored in the `bankData` and display the data on the HTML table elements, which we created in the previous article, where wi implemented all [dialogs](/articles/the-businessman-dialogs/).\n\n```js {numberLines: 248}\nconst setBankData = bankData => {\n  for (let i = 1; i < bankData.credit.length + 1; i++) {\n    const credit = bankData.credit[i - 1];\n\n    const row = i <= 6 ? 1 : 2;\n    const column = i <= 6 ? i : i - 6;\n    setElementData(`credit-${row}-${column}`, credit.amount);\n  }\n\n  for (let i = 1; i < bankData.deposit.length + 1; i++) {\n    const deposit = bankData.deposit[i - 1];\n\n    const row = i <= 6 ? 1 : 2;\n    const column = i <= 6 ? i : i - 6;\n    setElementData(`deposit-${row}-${column}`, deposit.amount);\n  }\n};\n```\n\n## Display hints and inputs\n\nWe have to add the hints and inputs to enter the data for lending and borrowing the money. The changes are done in the HTML, which are hidden originally and displayed only in reaction of correct action from the player.\n\n```html {numberLines: 130}\n<div id=\"lend-money\" class=\"hidden text-smaller text-color-turquoise\">\n  <div>\n    <label for=\"amount-to-lend\">\n      How much money do you want to lend:\n      <input\n        id=\"amount-to-lend\"\n        title=\"Amount to lend\"\n        type=\"number\"\n        min=\"0\"\n        class=\"text-color-turquoise\"\n      />\n    </label>\n  </div>\n  <div>\n    <label for=\"time-to-lend\">\n      Months to pay back:\n      <input\n        id=\"time-to-lend\"\n        title=\"Month to lend\"\n        type=\"number\"\n        min=\"1\"\n        max=\"12\"\n        class=\"text-color-turquoise\"\n      />\n    </label>\n  </div>\n</div>\n<div id=\"borrow-money\" class=\"hidden text-smaller text-color-turquoise\">\n  <div>\n    <label for=\"amount-to-borrow\">\n      How much money do you want to borrow:\n      <input\n        id=\"amount-to-borrow\"\n        title=\"Amount to borrow\"\n        type=\"number\"\n        min=\"0\"\n        class=\"text-color-turquoise\"\n      />\n    </label>\n  </div>\n  <div>\n    <label for=\"time-to-borrow\">\n      Months to pay back:\n      <input\n        id=\"time-to-borrow\"\n        title=\"Month to borrow\"\n        type=\"number\"\n        min=\"1\"\n        max=\"12\"\n        class=\"text-color-turquoise\"\n      />\n    </label>\n  </div>\n</div>\n<p id=\"bank-error\" class=\"text-smaller text-color-red\"></p>\n```\n\n## Handle the keyboard events\n\nThe next step is to handle the keyboard events. We need to add the `keydown` event listener to the `document` object and handle the key press events. We need to react .\n\n```js {numberLines: 397}\nconst assignBankWindowActions = () => {\n  let lendMoneyProcessing = false;\n  let borrowMoneyProcessing = false;\n\n  document.addEventListener(\n    \"keydown\",\n    e => {\n      const bankWindow = document.getElementById(\"bank-main\");\n      // If the bank window is hidden, we don't need to handle the key press events.\n      if (bankWindow.classList.contains(\"hidden\")) {\n        return;\n      }\n\n      const lendMoneyKeyBinding = \"l\";\n      const borrowMoneyKeyBinding = \"b\";\n\n      ...\n\n      if (  //L438\n        e.key === lendMoneyKeyBinding ||\n        (e.key === lendMoneyKeyBinding.toUpperCase() && e.shiftKey)\n      ) {\n        // If the player is already in the process of borrowing money, we can't handle lending.\n        if (borrowMoneyProcessing) {\n          return;\n        }\n\n        ...\n\n        lendMoneyProcessing = true;  //L446\n      }\n\n      if (\n        e.key === borrowMoneyKeyBinding ||\n        (e.key === borrowMoneyKeyBinding.toUpperCase() && e.shiftKey)\n      ) {\n        // If the player is already in the process of lending money, we can't handle borrowing.\n        if (lendMoneyProcessing) {\n          return;\n        }\n\n        ...\n\n        borrowMoneyProcessing = true;  //L457\n      }\n\n      // The main logic will be on the Enter and Tab keys.\n      if (e.key === \"Enter\" || e.key === \"Tab\") {\n        ...\n      }  //L528\n\n      // If the player presses the Escape key, we need to clean the data hide the bank window.\n      if (e.key === \"Escape\") {\n        ...\n      }\n    },\n    true\n  );\n};\n```\n\nNow, lets introuduce the clean up logic. Thei logic will be used only inside the `keydown` event handler, so we can use the JavaScript closures and define the function inside the event handler\nand will not leak the function outside of it (this process is also called **encapsulation** which we will discuss in later articles). We call this function on the `Escape` key press, also we will call it\nwhen the player will press the `Enter` or `Tab` keys, as we will need to clean the data and hide the bank window on the final stage of the bank transaction.\n\n```js {numberLines: 422}\nconst cleanPrompts = () => {\n  lendMoney.classList.add(\"hidden\");\n  borrowMoney.classList.add(\"hidden\");\n\n  amountToLend.value = \"\";\n  amountToBorrow.value = \"\";\n\n  timeToLend.value = \"\";\n  timeToBorrow.value = \"\";\n\n  bankError.innerText = \"\";\n\n  lendMoneyProcessing = false;\n  borrowMoneyProcessing = false;\n};\n\n...\n\nif (e.key === 'Escape') {  //L530\n    cleanPrompts();\n}\n```\n\nThe main logic of lending money is done in the `Enter` and `Tab` keys handling.\n\n```js {numberLines: 461}\nif (lendMoneyProcessing) {\n  // Convert the string values to numbers.\n  const amountValue = +amountToLend.value;\n  const timeValue = +timeToLend.value;\n\n  // Validate if there are enough money on the account to lend.\n  if (+amountValue > gameData.accountBalances.accountBalance) {\n    amountToLend.value = \"\";\n    bankError.innerText = \"You do not have enough money to lend.\";\n    return;\n  }\n\n  // Focus next input field.\n  if (e.target === amountToLend) {\n    timeToLend.focus();\n  }\n\n  // Validate the time to lend is in the range 1-12 month.\n  if (e.target === timeToLend) {\n    if (+timeValue > 12 || +timeValue < 1) {\n      timeToLend.value = \"\";\n      bankError.innerText =\n        \"You cannot lend money for more than 12 months and less than 1.\";\n      return;\n    }\n  }\n\n  if (amountValue > 0 && timeValue > 0 && timeValue < 13) {\n    // If the data is valid, we need to update the game data and hide the bank window.\n    gameData.bankData.deposit[timeValue - 1].amount += amountValue;\n    gameData.bankData.deposit[timeValue - 1].monthsToPayBack = timeValue;\n    // This is simplefication, the better logic would be to calculate the last day of the month, based on the month money should be returned.\n    gameData.bankData.deposit[timeValue - 1].returnDay =\n      gameData.today.getDate() > 28 ? 28 : gameData.today.getDate();\n\n    gameData.accountBalances.accountBalance -= amountValue;\n    gameData.accountBalances.depositBalance += amountValue;\n  } else {\n    return;\n  }\n}\n```\n\nThe borrowing logic is a little bit simpler, as we don't need to validate the amount of money on the account, as the player can borrow any amount of money.\n\n```js {numberLines: 495}\nif (borrowMoneyProcessing) {\n  // Convert the string values to numbers.\n  const amountValue = +amountToBorrow.value;\n  const timeValue = +timeToBorrow.value;\n\n  // Focus next input field.\n  if (e.target === amountToBorrow) {\n    timeToBorrow.focus();\n  }\n\n  // Validate the time to borrow is in the range 1-12 month.\n  if (e.target === timeToBorrow) {\n    if (+timeValue > 12 || +timeValue < 1) {\n      timeToBorrow.value = \"\";\n      bankError.innerText =\n        \"You cannot borrow money for more than 12 months and less than 1.\";\n      return;\n    }\n  }\n\n  if (amountValue > 0 && timeValue > 0 && timeValue < 13) {\n    // If the data is valid, we need to update the game data and hide the bank window.\n    gameData.bankData.credit[timeValue - 1].amount += amountValue;\n    gameData.bankData.credit[timeValue - 1].monthsToPayBack = timeValue;\n    // This is simplefication, the better logic would be to calculate the last day of the month, based on the month money should be returned.\n    gameData.bankData.credit[timeValue - 1].returnDay =\n      gameData.today.getDate() > 28 ? 28 : gameData.today.getDate();\n\n    gameData.accountBalances.accountBalance += amountValue;\n    gameData.accountBalances.creditBalance += amountValue;\n  } else {\n    return;\n  }\n}\n```\n\nAnd the last step is to update balances, clean the data and hide the bank window.\n\n```js {numberLines: 523}\nsetAccountsBalance(gameData.accountBalances);\nsetBankData(gameData.bankData);\n\ncleanPrompts();\ndocument.getElementById(\"bank-main\").classList.add(\"hidden\");\n```\n\n## Summary\n\nI'm highlighting the challenges of managing bank logic despite following the Single Responsibility Principle (SRP) for functions. I intentionally kept all the logic in the same file to demonstrate how even a small project\nled by a single developer can become difficult to manage with the growth of functions. This is a common mistake made by beginners. My intent is to help beginners become professionals by applying best practices, different techniques,\nand design patterns to make their projects more maintainable, readable, and testable.\n\nIn my future articles, I will describe SRP and other principles in more detail. I will also discuss design patterns and techniques that can help make projects better. Good code organization is essential for writing maintainable and testable code.\nThis means structuring your codebase into logical, organized chunks. Group related functions, objects, classes, and variables together. Achieving clean code involves following a set of best practices and standards, such as using meaningful names,\nkeeping functions small and focused, and using comments sparingly. Having a code base, which is readable and maintainable is essential for sustainable development.\n\nThe sources of the changes as usual are on [GiHub](https://github.com/smykhailov/the-businessman/releases/tag/v0.12).\n\nIn the next article, we will implement the logic for the [**Exchange**](/articles/the-businessman-exchange-logic). It will be similar in compexity to the bank logic, but will be able to reuse some techniques and code from the bank logic.\n","frontmatter":{"title":"The Businessman - Bank Logic","date":"2024-01-28T13:43:54.000Z","tags":["businessman","project","javascript"],"keywords":["business logic","javascript","the game","github compare","bank logic","bank","lending","borrowing","transactions"],"featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#0808f8","images":{"fallback":{"src":"/static/e3c79a8de4250e66f5e193ed7f836955/65210/cover.png","srcSet":"/static/e3c79a8de4250e66f5e193ed7f836955/1154e/cover.png 150w,\n/static/e3c79a8de4250e66f5e193ed7f836955/7d4d5/cover.png 300w,\n/static/e3c79a8de4250e66f5e193ed7f836955/65210/cover.png 600w","sizes":"(min-width: 600px) 600px, 100vw"},"sources":[{"srcSet":"/static/e3c79a8de4250e66f5e193ed7f836955/49f80/cover.webp 150w,\n/static/e3c79a8de4250e66f5e193ed7f836955/de298/cover.webp 300w,\n/static/e3c79a8de4250e66f5e193ed7f836955/e5496/cover.webp 600w","type":"image/webp","sizes":"(min-width: 600px) 600px, 100vw"}]},"width":600,"height":329}}}},"internal":{"contentFilePath":"/home/runner/work/sergii-dev/sergii-dev/articles/2024-01-28-the-businessman-bank-logic.mdx"},"fields":{"slug":"/articles/the-businessman-bank-logic/","readingTime":{"text":"9 min read","minutes":8.89,"time":533400}}}},"pageContext":{"id":"d520d68a-e9f7-5916-9611-73dd9f51bc99","frontmatter":{"title":"The Businessman - Bank Logic","date":"2024-01-28T13:43:54.000Z","published":true,"featuredImage":"./images/2024-01-28-the-businessman-bank-logic/cover.png","categories":["Businessman"],"tags":["businessman","project","javascript"],"keywords":["business logic","javascript","the game","github compare","bank logic","bank","lending","borrowing","transactions"]}}},"staticQueryHashes":["1739528850","3446427935"],"slicesMap":{}}